library(shiny)
runExample('shinydemo')
runExample('02_text')
setwd("C:/research")
runExample('02_text')
runExample('shinydemo')
runApp
runApp('shinydemo')
q()
source('c:/research/lineup/new-model-startup.r')
source(paste0(USERPATH, 'team_funct.r'))
source(paste0(USERPATH, 'player_funct.r'))
### want to rule out situations where there was a weirdly small number of players in each position
gbgdf$tgId = with(gbgdf, paste(season, teamgamenumber, team))
# let's see what a normal number actually is though
numPos = gbgdf %>%
filter(!is.na(mainpos)) %>%
group_by(tgId) %>%
summarise(numGk = sum( (startTime == '0') & (mainpos == 'GK')),
numD = sum( (startTime == '0') & (mainpos == 'D')),
numM = sum( (startTime == '0') & (mainpos %in% c('DMC', 'M'))),
numF = sum( (startTime == '0') & (mainpos %in% c('AM', 'FW'))),
numPosGK = sum(mainpos == 'GK'),
numPosD = sum(mainpos == 'D'),
numPosM = sum(mainpos  %in% c('DMC', 'M')),
numPosF = sum(mainpos %in% c('AM', 'FW')))
CheckByTeamPos = function(mySeason, myTeam, myPos) {
# let's take midfielders
# this feels like a special case of this. because you can only pick each element a maximum of once.
# so that's surely something else
# let's just do it anyway though
mcmfAvailable = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, available) %>%
mutate(available = as.numeric(available)) %>%
spread(key = player, available)
mcmfIsStart = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, isStart) %>%
mutate(isStart = as.numeric(isStart)) %>%
spread(key = player, isStart)
mcmfAvailable[which(is.na(mcmfAvailable), arr = T)] = FALSE
mcmfIsStart[which(is.na(mcmfIsStart), arr = T)] = FALSE
currentPlayer = names(mcmfIsStart)[-1]
availableMat = as.matrix(mcmfAvailable[,-1])
isStartMat = as.matrix(mcmfIsStart[,-1])
mcmfTotal = rowSums(mcmfIsStart[,2:ncol(mcmfIsStart)])
LikFunct = function(theta, mcmfTotal, availableMat, isStartMat) {
playerProb = c(1, exp(theta))
logProb = rep(NA, length(mcmfTotal))
for (j in 1:length(mcmfTotal)) {
availableIndex = which(availableMat[j,] == 1)
logProb[j] = log(BiasedUrn::dMFNCHypergeo(x = isStartMat[j,availableIndex],
m = availableMat[j,availableIndex],
n = mcmfTotal[j],
odds = playerProb[availableIndex]))
}
sumLogProb = sum(logProb)
return(-sumLogProb)
}
maxInfo = nlm(LikFunct, p = rep(0, length(currentPlayer) - 1),
mcmfTotal = mcmfTotal,
availableMat = availableMat,
isStartMat = isStartMat)
optWgtVec = c(1, exp(maxInfo$est))
cbind(currentPlayer, optWgtVec)[order(optWgtVec),]
# surprising variation among the players,let's see how that translates probability wise
# actually, i want expected prob for each player, can i get that?
cbind(currentPlayer, BiasedUrn::meanMFNCHypergeo(rep(1, length(currentPlayer)), 4, optWgtVec, precision = 0.1))
# that looks pretty reasonable to be fair
# compared to the raw data:
gbgdf %>% filter(season == mySeason & team == myTeam & mainpos %in% myPos) %>% group_by(player) %>% summarise(sum(available), sum(isStart))
# gundogan starts 0.75 of the time, but on some occasions, other players haven't been available. we're assuming that everyone's available in that calculation
# but of course we've got downweighting to worry about, plus tiredness, recovery from injury....ugh
}
CheckByTeamPos(1920, 'mancity', c('DMC', 'M'))
CheckByTeamPos = function(mySeason, myTeam, myPos) {
# let's take midfielders
# this feels like a special case of this. because you can only pick each element a maximum of once.
# so that's surely something else
# let's just do it anyway though
mcmfAvailable = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, available) %>%
mutate(available = as.numeric(available)) %>%
spread(key = player, available)
mcmfIsStart = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, isStart) %>%
mutate(isStart = as.numeric(isStart)) %>%
spread(key = player, isStart)
mcmfAvailable[which(is.na(mcmfAvailable), arr = T)] = FALSE
mcmfIsStart[which(is.na(mcmfIsStart), arr = T)] = FALSE
currentPlayer = names(mcmfIsStart)[-1]
availableMat = as.matrix(mcmfAvailable[,-1])
isStartMat = as.matrix(mcmfIsStart[,-1])
mcmfTotal = rowSums(mcmfIsStart[,2:ncol(mcmfIsStart)])
LikFunct = function(theta, mcmfTotal, availableMat, isStartMat) {
playerProb = c(1, exp(theta))
logProb = rep(NA, length(mcmfTotal))
for (j in 1:length(mcmfTotal)) {
availableIndex = which(availableMat[j,] == 1)
logProb[j] = log(BiasedUrn::dMFNCHypergeo(x = isStartMat[j,availableIndex],
m = availableMat[j,availableIndex],
n = mcmfTotal[j],
odds = playerProb[availableIndex]))
}
sumLogProb = sum(logProb)
return(-sumLogProb)
}
maxInfo = nlm(LikFunct, p = rep(0, length(currentPlayer) - 1),
mcmfTotal = mcmfTotal,
availableMat = availableMat,
isStartMat = isStartMat)
optWgtVec = c(1, exp(maxInfo$est))
cbind(currentPlayer, optWgtVec)[order(optWgtVec),]
# surprising variation among the players,let's see how that translates probability wise
# actually, i want expected prob for each player, can i get that?
print(cbind(currentPlayer, BiasedUrn::meanMFNCHypergeo(rep(1, length(currentPlayer)), 4, optWgtVec, precision = 0.1)))
# that looks pretty reasonable to be fair
# compared to the raw data:
print(gbgdf %>% filter(season == mySeason & team == myTeam & mainpos %in% myPos) %>% group_by(player) %>% summarise(sum(available), sum(isStart)))
# gundogan starts 0.75 of the time, but on some occasions, other players haven't been available. we're assuming that everyone's available in that calculation
# but of course we've got downweighting to worry about, plus tiredness, recovery from injury....ugh
}
CheckByTeamPos(1920, 'mancity', c('DMC', 'M'))
CheckByTeamPos(1920, 'mancity', c('AM', 'FW'))
CheckByTeamPos(1920, 'chelsea', c('AM', 'FW'))
CheckByTeamPos(1920, 'chelsea', c('DMC', 'M'))
CheckByTeamPos(1920, 'liverpool', c('DMC', 'M'))
CheckByTeamPos(1920, 'liverpool', c('AM', 'FW'))
mySeason = 1920
myTeam = 'liverpool'
myPos = c('AM', 'FW')
# let's take midfielders
# this feels like a special case of this. because you can only pick each element a maximum of once.
# so that's surely something else
# let's just do it anyway though
mcmfAvailable = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, available) %>%
mutate(available = as.numeric(available)) %>%
spread(key = player, available)
mcmfIsStart = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, isStart) %>%
mutate(isStart = as.numeric(isStart)) %>%
spread(key = player, isStart)
mcmfAvailable[which(is.na(mcmfAvailable), arr = T)] = FALSE
mcmfIsStart[which(is.na(mcmfIsStart), arr = T)] = FALSE
currentPlayer = names(mcmfIsStart)[-1]
availableMat = as.matrix(mcmfAvailable[,-1])
isStartMat = as.matrix(mcmfIsStart[,-1])
mcmfTotal = rowSums(mcmfIsStart[,2:ncol(mcmfIsStart)])
mcmfTotal
availableMat
isStartMat
LikFunct = function(theta, mcmfTotal, availableMat, isStartMat) {
playerProb = c(1, exp(theta))
logProb = rep(NA, length(mcmfTotal))
for (j in 1:length(mcmfTotal)) {
availableIndex = which(availableMat[j,] == 1)
logProb[j] = log(BiasedUrn::dMFNCHypergeo(x = isStartMat[j,availableIndex],
m = availableMat[j,availableIndex],
n = mcmfTotal[j],
odds = playerProb[availableIndex]))
}
sumLogProb = sum(logProb)
return(-sumLogProb)
}
maxInfo = nlm(LikFunct, p = rep(0, length(currentPlayer) - 1),
mcmfTotal = mcmfTotal,
availableMat = availableMat,
isStartMat = isStartMat)
maxInfo
optWgtVec = c(1, exp(maxInfo$est))
cbind(currentPlayer, optWgtVec)[order(optWgtVec),]
### combine the team spreadsheets into one nice dataframe
source('c:/research/general_startup.r')
suppressWarnings(library(dplyr))
suppressWarnings(library(tidyr))
suppressWarnings(library(lubridate))
USERPATH='c:/git/lineup/'
DATAPATH='d:/whoscored_data/'
setwd(USERPATH)
source('admin_funct.r')
options(warn=2, dplyr.print_max = 1e9)
if (FALSE) {
ffDataLoadingPath = paste0(USERPATH, 'ffDataLoading')
# usethis::create_package(ffDataLoadingPath)
devtools::load_all(ffDataLoadingPath)
#devtools::install(ffDataLoadingPath)
}
seasoninfo = read.csv(paste(DATAPATH,'seasoninfo.csv',sep=''))
currentseason = 1920
resultdf = ffDataLoading:::GetResultDF()
fixtdf = ffDataLoading:::GetFixtDF()
resultdf = ffDataLoading:::AlignGameweekAndSeasonWithResultDF(resultdf)
dum = ffDataLoading:::AlignOddsWithResultsAndFixtures(resultdf, fixtdf)
resultdf = dum$resultDF
fixtdf = dum$fixtDF
gbgdf = ffDataLoading::ReadGbgDF()
gbgdf = ffDataLoading::BolsterGbgDF(gbgdf, resultdf)
# i think the chances are, we will not be wanting the players who are unidentified any time soon
gbgdf = gbgdf %>%
filter(!is.na(player))
summarydf = ffDataLoading::GetSummaryDF(gbgdf)
playerDF = ffDataLoading:::ReadCurrentSeasonPlayerDF() %>%
rename(player = whoscoredPlayer) %>%
remove_column(c('soccerwayPlayer', 'ffuseswholename', 'adjustedwhoscoredPlayer'))
source(paste0(USERPATH, 'team_funct.r'))
source(paste0(USERPATH, 'player_funct.r'))
playerDF = ffModel:::CalculateUpToDatePlayerSmooth(gbgdf)
fixtdf = getfixturegoal(resultdf, fixtdf)
gbgdf = processdeserved(gbgdf)
summarydf=processdeserved(summarydf)
playerDF = ffModel:::CalculateLatestGoalAssistRate(playerDF, gbgdf, summarydf, resultDF)
playerfixtdf = getplayerfixture(fixtdf, playerDF, gbgdf)
playerfixtdf = getfixtureexpectedpoint(playerfixtdf)
playerDF = getplayervalue(playerDF, playerfixtdf)
currentteam = read.csv(paste(DATAPATH, 'currentteam.csv', sep = ''))
forcedInclusionExclusion = read.csv(paste0(DATAPATH, 'forced-inclusion-exclusion.csv'))
## hmm, it seems by adding heavy hitters, you don't actually lose anything like the number of points you might expect
# first issue is to sort out the minutes though
currentmoney = 99.6
source('get-optimal-team.r')
