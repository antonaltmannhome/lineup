library(shiny)
runExample('shinydemo')
runExample('02_text')
setwd("C:/research")
runExample('02_text')
runExample('shinydemo')
runApp
runApp('shinydemo')
q()
source('c:/research/lineup/new-model-startup.r')
source(paste0(USERPATH, 'team_funct.r'))
source(paste0(USERPATH, 'player_funct.r'))
### want to rule out situations where there was a weirdly small number of players in each position
gbgdf$tgId = with(gbgdf, paste(season, teamgamenumber, team))
# let's see what a normal number actually is though
numPos = gbgdf %>%
filter(!is.na(mainpos)) %>%
group_by(tgId) %>%
summarise(numGk = sum( (startTime == '0') & (mainpos == 'GK')),
numD = sum( (startTime == '0') & (mainpos == 'D')),
numM = sum( (startTime == '0') & (mainpos %in% c('DMC', 'M'))),
numF = sum( (startTime == '0') & (mainpos %in% c('AM', 'FW'))),
numPosGK = sum(mainpos == 'GK'),
numPosD = sum(mainpos == 'D'),
numPosM = sum(mainpos  %in% c('DMC', 'M')),
numPosF = sum(mainpos %in% c('AM', 'FW')))
CheckByTeamPos = function(mySeason, myTeam, myPos) {
# let's take midfielders
# this feels like a special case of this. because you can only pick each element a maximum of once.
# so that's surely something else
# let's just do it anyway though
mcmfAvailable = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, available) %>%
mutate(available = as.numeric(available)) %>%
spread(key = player, available)
mcmfIsStart = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, isStart) %>%
mutate(isStart = as.numeric(isStart)) %>%
spread(key = player, isStart)
mcmfAvailable[which(is.na(mcmfAvailable), arr = T)] = FALSE
mcmfIsStart[which(is.na(mcmfIsStart), arr = T)] = FALSE
currentPlayer = names(mcmfIsStart)[-1]
availableMat = as.matrix(mcmfAvailable[,-1])
isStartMat = as.matrix(mcmfIsStart[,-1])
mcmfTotal = rowSums(mcmfIsStart[,2:ncol(mcmfIsStart)])
LikFunct = function(theta, mcmfTotal, availableMat, isStartMat) {
playerProb = c(1, exp(theta))
logProb = rep(NA, length(mcmfTotal))
for (j in 1:length(mcmfTotal)) {
availableIndex = which(availableMat[j,] == 1)
logProb[j] = log(BiasedUrn::dMFNCHypergeo(x = isStartMat[j,availableIndex],
m = availableMat[j,availableIndex],
n = mcmfTotal[j],
odds = playerProb[availableIndex]))
}
sumLogProb = sum(logProb)
return(-sumLogProb)
}
maxInfo = nlm(LikFunct, p = rep(0, length(currentPlayer) - 1),
mcmfTotal = mcmfTotal,
availableMat = availableMat,
isStartMat = isStartMat)
optWgtVec = c(1, exp(maxInfo$est))
cbind(currentPlayer, optWgtVec)[order(optWgtVec),]
# surprising variation among the players,let's see how that translates probability wise
# actually, i want expected prob for each player, can i get that?
cbind(currentPlayer, BiasedUrn::meanMFNCHypergeo(rep(1, length(currentPlayer)), 4, optWgtVec, precision = 0.1))
# that looks pretty reasonable to be fair
# compared to the raw data:
gbgdf %>% filter(season == mySeason & team == myTeam & mainpos %in% myPos) %>% group_by(player) %>% summarise(sum(available), sum(isStart))
# gundogan starts 0.75 of the time, but on some occasions, other players haven't been available. we're assuming that everyone's available in that calculation
# but of course we've got downweighting to worry about, plus tiredness, recovery from injury....ugh
}
CheckByTeamPos(1920, 'mancity', c('DMC', 'M'))
CheckByTeamPos = function(mySeason, myTeam, myPos) {
# let's take midfielders
# this feels like a special case of this. because you can only pick each element a maximum of once.
# so that's surely something else
# let's just do it anyway though
mcmfAvailable = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, available) %>%
mutate(available = as.numeric(available)) %>%
spread(key = player, available)
mcmfIsStart = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, isStart) %>%
mutate(isStart = as.numeric(isStart)) %>%
spread(key = player, isStart)
mcmfAvailable[which(is.na(mcmfAvailable), arr = T)] = FALSE
mcmfIsStart[which(is.na(mcmfIsStart), arr = T)] = FALSE
currentPlayer = names(mcmfIsStart)[-1]
availableMat = as.matrix(mcmfAvailable[,-1])
isStartMat = as.matrix(mcmfIsStart[,-1])
mcmfTotal = rowSums(mcmfIsStart[,2:ncol(mcmfIsStart)])
LikFunct = function(theta, mcmfTotal, availableMat, isStartMat) {
playerProb = c(1, exp(theta))
logProb = rep(NA, length(mcmfTotal))
for (j in 1:length(mcmfTotal)) {
availableIndex = which(availableMat[j,] == 1)
logProb[j] = log(BiasedUrn::dMFNCHypergeo(x = isStartMat[j,availableIndex],
m = availableMat[j,availableIndex],
n = mcmfTotal[j],
odds = playerProb[availableIndex]))
}
sumLogProb = sum(logProb)
return(-sumLogProb)
}
maxInfo = nlm(LikFunct, p = rep(0, length(currentPlayer) - 1),
mcmfTotal = mcmfTotal,
availableMat = availableMat,
isStartMat = isStartMat)
optWgtVec = c(1, exp(maxInfo$est))
cbind(currentPlayer, optWgtVec)[order(optWgtVec),]
# surprising variation among the players,let's see how that translates probability wise
# actually, i want expected prob for each player, can i get that?
print(cbind(currentPlayer, BiasedUrn::meanMFNCHypergeo(rep(1, length(currentPlayer)), 4, optWgtVec, precision = 0.1)))
# that looks pretty reasonable to be fair
# compared to the raw data:
print(gbgdf %>% filter(season == mySeason & team == myTeam & mainpos %in% myPos) %>% group_by(player) %>% summarise(sum(available), sum(isStart)))
# gundogan starts 0.75 of the time, but on some occasions, other players haven't been available. we're assuming that everyone's available in that calculation
# but of course we've got downweighting to worry about, plus tiredness, recovery from injury....ugh
}
CheckByTeamPos(1920, 'mancity', c('DMC', 'M'))
CheckByTeamPos(1920, 'mancity', c('AM', 'FW'))
CheckByTeamPos(1920, 'chelsea', c('AM', 'FW'))
CheckByTeamPos(1920, 'chelsea', c('DMC', 'M'))
CheckByTeamPos(1920, 'liverpool', c('DMC', 'M'))
CheckByTeamPos(1920, 'liverpool', c('AM', 'FW'))
mySeason = 1920
myTeam = 'liverpool'
myPos = c('AM', 'FW')
# let's take midfielders
# this feels like a special case of this. because you can only pick each element a maximum of once.
# so that's surely something else
# let's just do it anyway though
mcmfAvailable = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, available) %>%
mutate(available = as.numeric(available)) %>%
spread(key = player, available)
mcmfIsStart = gbgdf %>%
filter(season == mySeason & mainpos %in% myPos & team == myTeam) %>%
select(tgId, player, isStart) %>%
mutate(isStart = as.numeric(isStart)) %>%
spread(key = player, isStart)
mcmfAvailable[which(is.na(mcmfAvailable), arr = T)] = FALSE
mcmfIsStart[which(is.na(mcmfIsStart), arr = T)] = FALSE
currentPlayer = names(mcmfIsStart)[-1]
availableMat = as.matrix(mcmfAvailable[,-1])
isStartMat = as.matrix(mcmfIsStart[,-1])
mcmfTotal = rowSums(mcmfIsStart[,2:ncol(mcmfIsStart)])
mcmfTotal
availableMat
isStartMat
LikFunct = function(theta, mcmfTotal, availableMat, isStartMat) {
playerProb = c(1, exp(theta))
logProb = rep(NA, length(mcmfTotal))
for (j in 1:length(mcmfTotal)) {
availableIndex = which(availableMat[j,] == 1)
logProb[j] = log(BiasedUrn::dMFNCHypergeo(x = isStartMat[j,availableIndex],
m = availableMat[j,availableIndex],
n = mcmfTotal[j],
odds = playerProb[availableIndex]))
}
sumLogProb = sum(logProb)
return(-sumLogProb)
}
maxInfo = nlm(LikFunct, p = rep(0, length(currentPlayer) - 1),
mcmfTotal = mcmfTotal,
availableMat = availableMat,
isStartMat = isStartMat)
maxInfo
optWgtVec = c(1, exp(maxInfo$est))
cbind(currentPlayer, optWgtVec)[order(optWgtVec),]
